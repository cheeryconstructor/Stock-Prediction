# -*- coding: utf-8 -*-
"""Time Series Data Science

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jrkh1hlyhmj5fg74ZgR1ujWnvMlHPQjv
"""

'''
#DATE TIME INDEXING
import pandas as pd
df= pd.read_csv("DATA.csv",parse_dates=["Month"],index_col="Month")
df.columns=["Close"]

df.drop(df.tail(2).index,inplace=True)
print(df)'''

#DATE TIME INDEXING
import pandas as pd
df= pd.read_csv("Netflix.csv",parse_dates=["Date"],index_col="Date")
df

df["2020-01"].Close.mean()

df["2019-01-01":"2020-01-01"].Close.mean()

"""#RESAMPLING
df = df.resample("D").mean()
print(df)"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline 
df.plot()



#Fill holes in the dates
# Time Series

df.asfreq("D", method="pad")

rng = pd.date_range(start="2019-01-01", periods =72, freq='D')
print(rng)

df.plot()

rollmean= df.rolling(window=2).mean()
rollstd= df.rolling(window=2).std()

print(rollmean)
print(rollstd)

orig = plt.plot(df, color="Blue",label="Original")
mean = plt.plot(rollmean, color="Red",label="Rolling Mean")
std = plt.plot(rollstd, color="Black",label="Rolling Std")
plt.legend(loc='best')
plt.title("Rolling Mean and Std Deviation")

#DICKEY FULLER TEST (TO CHECK THAT DATA IS STATIONARY OR NOT)

from statsmodels.tsa.stattools import adfuller

test_result = adfuller(df['Close'])

def adfuller_test(Close):
  result = adfuller(Close)
  labels = ["ADF statistics","p-value","Lag Used","No. of Observations"]
  for value,label in zip(result,labels):
    print(label + ":" + str(value))

  if (result[1]<=0.05):
    print("stationary data")
  else:
    print("non-stationary data")

adfuller_test(df["Close"])

##LOG

import numpy as np

df["df_log"] = np.log(df["Close"])
print(df["df_log"])
df["df_log"].plot()

adfuller_test(df["df_log"])

### LOG + Rolling Average

df["df_log_moving_average"] = df["df_log"].rolling(window = 14).mean()

df["df_log_shift"] = df["df_log"] - df["df_log_moving_average"]

df["df_log_shift"].plot()

adfuller_test(df["df_log_shift"].dropna())

print(df["df_log_shift"])

print(df)

### EXPONENTIAL MOVING AVERAGE 

exponential_decay_weight_average = df_log.ewm(halflife=10, min_periods=0, adjust=True).mean()

exponential_decay_weight_average.plot()

adfuller_test(exponential_decay_weight_average.dropna())

### LOG + SHIFTING 

df_log_shift = df_log- df_log.shift(14)

df_log_shift.plot()

adfuller_test(df_log_shift.dropna())

from statsmodels.tsa.seasonal import seasonal_decompose

decomposition = seasonal_decompose(df["Close"])
trend = decomposition.trend
seasonal = decomposition.seasonal
residual = decomposition.resid

plt.plot(df_log, color="Red",label="Original")
plt.plot(trend,label="trend")
plt.plot(seasonal,label="seasonal")
plt.plot(residual,label="residual")

# We have to make our data stationary so now we do differencing

df["Close First Difference"] = df["Close"]- df["Close"].shift(50)

# Note here our data is not seasonal thus we have to use " .shift(1) ", else we should use ".shift(12 or period)"

df.head()

df.plot()

adfuller_test(df["Close First Difference"].dropna())

print(df)

from statsmodels.graphics.tsaplots import acf, pacf
import matplotlib.pyplot as plt 
import numpy as np

lag_acf = acf(df["df_log_shift"].dropna() , nlags=50)
plt.figure(figsize=(16, 7))
plt.plot(lag_acf, marker="o")
plt.axhline(y=0,linestyle='--',color='gray')
plt.axhline(y=-1.96/np.sqrt(len(df["df_log_shift"].dropna())),linestyle='--',color='gray')
plt.axhline(y=1.96/np.sqrt(len(df["df_log_shift"].dropna())),linestyle='--',color='gray')
plt.title('Autocorrelation Function')
plt.xlabel('number of lags')
plt.ylabel('correlation')
plt.tight_layout()

lag_pacf = pacf(df["df_log_shift"].dropna() , nlags=50, method='ols')

#PLOT PACF
plt.figure(figsize=(16, 7))
plt.plot(lag_pacf, marker="o")
plt.axhline(y=0,linestyle='--',color='gray')
plt.axhline(y=-1.96/np.sqrt(len(df["df_log_shift"].dropna() )),linestyle='--',color='gray')
plt.axhline(y=1.96/np.sqrt(len(df["df_log_shift"].dropna() )),linestyle='--',color='gray')
plt.title('Partial Autocorrelation Function')
plt.xlabel('number of lags')
plt.ylabel('correlation')
plt.tight_layout()

from statsmodels.tsa.stattools import arma_order_select_ic

arma_order_select_ic(df["df_log_shift"].dropna())

### AR

from statsmodels.tsa.arima_model import ARIMA
model = ARIMA(df["df_log_shift"].dropna(),order=(2,2,0))

results_AR = model.fit(disp=-1)
plt.plot(df["df_log_shift"].dropna())
plt.plot(results_AR.fittedvalues, color="Red")
plt.show()

print(df["df_log_shift"].dropna())
print(results_AR.fittedvalues)

#MA

from statsmodels.tsa.arima_model import ARIMA
model = ARIMA(df["df_log_shift"].dropna(),order=(0,0,19))

results_MA = model.fit(disp=-1)
plt.plot(df["df_log_shift"].dropna())
plt.plot(results_MA.fittedvalues, color="Red")
plt.show()

#ARIMA

from statsmodels.tsa.arima_model import ARIMA
model = ARIMA(df["df_log_shift"].dropna(),order=(2,2,5))

results_ARIMA = model.fit(disp=-1)
plt.plot(df["df_log_shift"].dropna())
plt.plot(results_ARIMA.fittedvalues, color="Red")
plt.show()

print(df["df_log_shift"].dropna())

print(results_ARIMA.fittedvalues)



#TRANSFORMATION OF DATA

predication_ARIMA_cumm_sum = results_ARIMA.fittedvalues.cumsum()

print(predication_ARIMA_cumm_sum)


predication_ARIMA_cumm_sum = predication_ARIMA_cumm_sum.cumsum()

print(predication_ARIMA_cumm_sum)

plt.plot(df["df_log_shift"].dropna())
plt.plot(predication_ARIMA_cumm_sum, color="Red")
plt.show()

predictions_AR_log = pd.Series(df["df_log_shift"].iloc[0])

predictions_AR_log = predictions_AR_log.add(predication_ARIMA_cumm_sum, fill_value=0)

print(predictions_AR_log.dropna())

prediction_ARIMA = np.exp(predictions_AR_log.dropna())
plt.plot(df["df_log_shift"].dropna())

plt.plot(prediction_ARIMA)

df['forecast'] = model_fit.predict(start=80,end=500,dynamic=True)
df[["Close","forecast"]].plot(figsize=(16,7))

# Here p=1, d=1, q=1 

from statsmodels.tsa.arima_model import ARIMA
# ARIMA SHOULD BE USED FOR NON SEASONAL DATA

model = ARIMA(df["Close"],order=(2,1,1))
model_fit = model.fit()

model_fit.summary()

df['forecast'] = model_fit.predict(start=80,end=103,dynamic=True)
df[["Close","forecast"]].plot(figsize=(16,7))

import statsmodels.api as sm

model = sm.tsa.statespace.SARIMAX(df["Close"],order=(2,1,1),seasonal_order=(2,1,1,1))
results=model.fit()

df['forecast'] = results.predict(start=60,end=850,dynamic=True)
df[["Close","forecast"]].plot(figsize=(16,7))

from pandas.tseries.offsets import DateOffset

future_dates = [df.index[-1]+ DateOffset(days = x) for x in range(0,30)]

future_dataset_df= pd.DataFrame(index=future_dates[1:],columns= df.columns)

future_dataset_df.tail()

future_df = pd.concat([df, future_dataset_df])
future_df['forecast'] = results.predict(start=400, end=500,dynamic= True)
future_df[["Close","forecast"]].plot(figsize=(16,7))

